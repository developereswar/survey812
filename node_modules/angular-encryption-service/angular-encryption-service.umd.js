(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('text-encoding-utf-8'), require('typescript-base64-arraybuffer')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/common', 'text-encoding-utf-8', 'typescript-base64-arraybuffer'], factory) :
	(factory((global['angular-encryption-service'] = {}),global._angular_core,global._angular_common,global.textEncodingUtf8,global.typescriptBase64Arraybuffer));
}(this, (function (exports,_angular_core,_angular_common,textEncodingUtf8,typescriptBase64Arraybuffer) { 'use strict';

var CRYPT_CONFIG_PROVIDER = new _angular_core.InjectionToken('crypt.config.provider');

var EncryptionService = (function () {
    /**
     * @param {?} config
     */
    function EncryptionService(config) {
        this.config = config;
    }
    /**
     * Given a passphrase, generate a CryptoKey for the passphrase using the salt
     * returned by the CryptConfigProvider.
     * @param {?} passphrase
     * @return {?}
     */
    EncryptionService.prototype.generateKey = function (passphrase) {
        return this.config.getSalt().then(function (salt) {
            var /** @type {?} */ passphraseBytes = new textEncodingUtf8.TextEncoder().encode(passphrase);
            var /** @type {?} */ importedKeyPromise = window.crypto.subtle.importKey('raw', passphraseBytes, { 'name': 'PBKDF2' }, false, ['deriveKey']);
            var /** @type {?} */ derivedKeyPromise = importedKeyPromise.then(function (key) {
                return window.crypto.subtle.deriveKey({
                    'name': 'PBKDF2',
                    'salt': typescriptBase64Arraybuffer.decode(salt),
                    // This should take around 0.5s to 1s
                    'iterations': 1000000,
                    'hash': 'SHA-256'
                }, key, { 'name': 'AES-CBC', 'length': 256 }, false, ['encrypt', 'decrypt']);
            });
            return derivedKeyPromise;
        });
    };
    /**
     * @param {?} text
     * @param {?} key
     * @return {?}
     */
    EncryptionService.prototype.encrypt = function (text, key) {
        var /** @type {?} */ iv = new Uint8Array(16);
        window.crypto.getRandomValues(iv);
        return (window.crypto.subtle.encrypt({ 'name': 'AES-CBC', 'iv': iv }, key, new textEncodingUtf8.TextEncoder().encode(text)).then(function (cipherBuffer) {
            // Need to implement base64 stuff here:
            return typescriptBase64Arraybuffer.encode(iv.buffer) + ':' + typescriptBase64Arraybuffer.encode(cipherBuffer);
        }));
    };
    /**
     * @param {?} cipherText
     * @param {?} key
     * @return {?}
     */
    EncryptionService.prototype.decrypt = function (cipherText, key) {
        try {
            var /** @type {?} */ pieces = cipherText.split(':');
            if (pieces.length !== 2) {
                return Promise.reject(new Error('encrypted text not formatted properly; missing ":"'));
            }
            var /** @type {?} */ iv = typescriptBase64Arraybuffer.decode(pieces[0]);
            var /** @type {?} */ buffer = typescriptBase64Arraybuffer.decode(pieces[1]);
            return (window.crypto.subtle.decrypt({ 'name': 'AES-CBC', 'iv': iv }, key, buffer).then(function (decryptedBuffer) {
                return new textEncodingUtf8.TextDecoder().decode(new Uint8Array(decryptedBuffer));
            }));
        }
        catch (e) {
            return Promise.reject(e);
        }
    };
    return EncryptionService;
}());
EncryptionService.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
EncryptionService.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [CRYPT_CONFIG_PROVIDER,] },] },
]; };

var EncryptionServiceModule = (function () {
    function EncryptionServiceModule() {
    }
    /**
     * @return {?}
     */
    EncryptionServiceModule.forRoot = function () {
        return {
            ngModule: EncryptionServiceModule,
            providers: [EncryptionService]
        };
    };
    return EncryptionServiceModule;
}());
EncryptionServiceModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                imports: [
                    _angular_common.CommonModule
                ]
            },] },
];
/**
 * @nocollapse
 */
EncryptionServiceModule.ctorParameters = function () { return []; };

exports.EncryptionServiceModule = EncryptionServiceModule;
exports.CRYPT_CONFIG_PROVIDER = CRYPT_CONFIG_PROVIDER;
exports.EncryptionService = EncryptionService;

Object.defineProperty(exports, '__esModule', { value: true });

})));
