import { Inject, Injectable, InjectionToken, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { TextDecoder, TextEncoder } from 'text-encoding-utf-8';
import { decode, encode } from 'typescript-base64-arraybuffer';

var CRYPT_CONFIG_PROVIDER = new InjectionToken('crypt.config.provider');

var EncryptionService = (function () {
    /**
     * @param {?} config
     */
    function EncryptionService(config) {
        this.config = config;
    }
    /**
     * Given a passphrase, generate a CryptoKey for the passphrase using the salt
     * returned by the CryptConfigProvider.
     * @param {?} passphrase
     * @return {?}
     */
    EncryptionService.prototype.generateKey = function (passphrase) {
        return this.config.getSalt().then(function (salt) {
            var /** @type {?} */ passphraseBytes = new TextEncoder().encode(passphrase);
            var /** @type {?} */ importedKeyPromise = window.crypto.subtle.importKey('raw', passphraseBytes, { 'name': 'PBKDF2' }, false, ['deriveKey']);
            var /** @type {?} */ derivedKeyPromise = importedKeyPromise.then(function (key) {
                return window.crypto.subtle.deriveKey({
                    'name': 'PBKDF2',
                    'salt': decode(salt),
                    // This should take around 0.5s to 1s
                    'iterations': 1000000,
                    'hash': 'SHA-256'
                }, key, { 'name': 'AES-CBC', 'length': 256 }, false, ['encrypt', 'decrypt']);
            });
            return derivedKeyPromise;
        });
    };
    /**
     * @param {?} text
     * @param {?} key
     * @return {?}
     */
    EncryptionService.prototype.encrypt = function (text, key) {
        var /** @type {?} */ iv = new Uint8Array(16);
        window.crypto.getRandomValues(iv);
        return (window.crypto.subtle.encrypt({ 'name': 'AES-CBC', 'iv': iv }, key, new TextEncoder().encode(text)).then(function (cipherBuffer) {
            // Need to implement base64 stuff here:
            return encode(iv.buffer) + ':' + encode(cipherBuffer);
        }));
    };
    /**
     * @param {?} cipherText
     * @param {?} key
     * @return {?}
     */
    EncryptionService.prototype.decrypt = function (cipherText, key) {
        try {
            var /** @type {?} */ pieces = cipherText.split(':');
            if (pieces.length !== 2) {
                return Promise.reject(new Error('encrypted text not formatted properly; missing ":"'));
            }
            var /** @type {?} */ iv = decode(pieces[0]);
            var /** @type {?} */ buffer = decode(pieces[1]);
            return (window.crypto.subtle.decrypt({ 'name': 'AES-CBC', 'iv': iv }, key, buffer).then(function (decryptedBuffer) {
                return new TextDecoder().decode(new Uint8Array(decryptedBuffer));
            }));
        }
        catch (e) {
            return Promise.reject(e);
        }
    };
    return EncryptionService;
}());
EncryptionService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
EncryptionService.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: Inject, args: [CRYPT_CONFIG_PROVIDER,] },] },
]; };

var EncryptionServiceModule = (function () {
    function EncryptionServiceModule() {
    }
    /**
     * @return {?}
     */
    EncryptionServiceModule.forRoot = function () {
        return {
            ngModule: EncryptionServiceModule,
            providers: [EncryptionService]
        };
    };
    return EncryptionServiceModule;
}());
EncryptionServiceModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ]
            },] },
];
/**
 * @nocollapse
 */
EncryptionServiceModule.ctorParameters = function () { return []; };

export { EncryptionServiceModule, CRYPT_CONFIG_PROVIDER, EncryptionService };
